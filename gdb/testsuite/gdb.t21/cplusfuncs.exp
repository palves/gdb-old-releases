# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

# Variables to keep track of number of passes, number of failures, and
# a limit on the number of failures.  We periodically test to see how
# many failures have occurred, and abandon a particular test if the
# maximum has been exceeded.  Note that exactly how many failures are
# allowed depends on the setting of max_dem_failcount, how often we
# test it, and exactly where the errors occur with respect to the tests.

set dem_passcount 0
set dem_failcount 0
set max_dem_failcount 20

#
#  Cause gdb to lookup a specific C++ function and print the demangled
#  form.
#

proc info_func { regex demangled } {
    global prompt
    global dem_passcount
    global dem_failcount
    global xfail_flag

    send "info function $regex\n"
    expect {
	-re "File .*:\r\n$demangled\r\n$prompt $" {
	    incr dem_passcount
	    if $xfail_flag then { pass "info function for \"$regex\"" }
	}
	-re ".*$prompt $" {
	    incr dem_failcount
	    fail "info function for \"$regex\""
	}
	timeout {
	    incr dem_failcount
	    fail "info function for \"$regex\" (timeout)"
	}
    }
}

#
#  Run print &'$arg' on the input arg and verify that we can correctly
#  lookup the fully qualified C++ function.
#  We ignore the return type of the function since we are only interested
#  in the rootname and arguments part.
#

proc print_addr_of { arg } {
    global prompt
    global dem_passcount
    global dem_failcount
    global hex
    global xfail_flag

    send "print &'$arg'\n"
    expect {
	-re ".* = .* $hex <" {}
	-re ".*$prompt $" {
	    incr dem_failcount ; fail "print &'$arg'" ; return
	}
	timeout {
	    incr dem_failcount ; fail "print &'$arg' (timeout)" ; return
	}
    }
    expect {
	"$arg" {}
	-re ".*$prompt $" {
	    incr dem_failcount ; fail "print &'$arg'" ; return
	}
	timeout {
	    incr dem_failcount ; fail "print &'$arg' (timeout)" ; return
	}
    }
    expect {
	-re ">\r\n$prompt $" {}
	-re ".*$prompt $" {
	    incr dem_failcount ; fail "print &'$arg'" ; return
	}
	timeout {
	    incr dem_failcount ; fail "print &'$arg' (timeout)" ; return
	}
    }
    incr dem_passcount
    if $xfail_flag then { pass "print &'$arg'" }
}

#
# Test name demangling for operators.
#
# The '(' at the end of each regex input pattern is so that we match only
# the one we are looking for.  I.E. "operator&" would match both
# "operator&(foo &)" and "operator&&(foo &)".
#

proc test_lookup_operator_functions {} {
    global dem_passcount
    global dem_failcount
    global max_dem_failcount

    set dem_passcount 0
    set dem_failcount 0

    # These tests don't work for COFF targets; don't even try them
    if [istarget "a29k-*-udi"] then {
	setup_xfail "a29k-*-udi"
	fail "skipping operator tests"
	return
    }

    info_func "operator&&("  "void foo::operator&&\(foo &\);"
    info_func "operator&=("  "void foo::operator&=\(foo &\);"
    info_func "operator&("  "void foo::operator&\(foo &\);"
    info_func "operator/=("  "void foo::operator/=\(foo &\);"
    info_func "operator^=("  "void foo::operator\^=\(foo &\);"
    info_func "operator<<=("  "void foo::operator<<=\(foo &\);"
    info_func "operator%=("  "void foo::operator%=\(foo &\);"
    info_func "operator-=("  "void foo::operator-=\(foo &\);"

    # There doesn't appear to be anyway to get '*' treated as a character
    # to match, rather than as a regex special character.
    setup_xfail "*-*-*"
    info_func "operator\*=("  "void foo::operator\*=\(foo &\);"

    info_func "operator|=("  "void foo::operator\|=\(foo &\);"
    setup_xfail "sparc-sun-solaris2.*"
    info_func "operator+=("  "void foo::operator\+=\(foo &\);"
    info_func "operator>>=("  "void foo::operator>>=\(foo &\);"
    info_func "operator=("  "void foo::operator=\(foo &\);"
    info_func "operator()("  "void foo::operator\(\)\(foo &\);"

    # The function should be "operator," not "operator, ".  (note space)
    # This test will work; I've commented it out because it should not
    # count as a pass, since it is incorrect.  Ian Taylor.
    # info_func "operator, ("  "void foo::operator, \(foo &\);"
    setup_xfail "*-*-*"
    info_func "operator,("  "void foo::operator,\(foo &\);"

    info_func "operator~("  "void foo::operator~\(void\);"
    info_func "operator delete("  "void foo::operator delete\(void \*\);"
    info_func "operator/("  "void foo::operator/\(foo &\);"
    info_func "operator==("  "void foo::operator==\(foo &\);"
    info_func "operator^("  "void foo::operator\^\(foo &\);"

    if $dem_failcount>$max_dem_failcount then {
	fail "remaining tests suppressed after $dem_failcount failures..."
	return
    }

    info_func "operator>=("  "void foo::operator>=\(foo &\);"
    info_func "operator>("  "void foo::operator>\(foo &\);"
    info_func "operator<=("  "void foo::operator<=\(foo &\);"
    info_func "operator<<("  "void foo::operator<<\(foo &\);"
    info_func "operator<("  "void foo::operator<\(foo &\);"
    info_func "operator%("  "void foo::operator%\(foo &\);"
    info_func "operator-("  "void foo::operator-\(foo &\);"

    # There doesn't appear to be anyway to get '*' treated as a character
    # to match, rather than as a regex special character.
    setup_xfail "*-*-*"
    info_func "operator\*("  "void foo::operator\*\(foo &\);"

    info_func "operator--("  "void foo::operator--\(int\);"
    info_func "operator!=("  "void foo::operator!=\(foo &\);"
    info_func "operator!("  "void foo::operator!\(void\);"
    info_func "operator new("  "void \*foo::operator new\(int\);"
    info_func "operator||("  "void foo::operator\|\|\(foo &\);"
    info_func "operator char \*("  "char \*foo::operator char \*\(void\);"
    info_func "operator int("  "int foo::operator int\(void\);"
    info_func "operator|("  "void foo::operator\|\(foo &\);"
    setup_xfail "sparc-sun-solaris2.*"
    info_func "operator+("  "void foo::operator\+\(foo &\);"
    setup_xfail "sparc-sun-solaris2.*"
    info_func "operator++("  "void foo::operator\+\+\(int\);"
    info_func "operator->("  "void foo::operator->\(void\);"
    info_func "operator->\*("  "void foo::operator->\*\(foo &\);"
    info_func "operator>>("  "void foo::operator>>\(foo &\);"

    # There doesn't appear to be anyway to get '[' and ']' treated as
    # characters to match, rather than as regex special characters.
    setup_xfail "*-*-*"
    info_func "operator\\\[\\\]("  "void foo::operator\\\[\\\]\(foo &\);"

    if $dem_passcount then {
	pass "$dem_passcount correct rootname operator function lookups"
    }
}


proc test_paddr_operator_functions {} {
    global dem_passcount
    global dem_failcount
    global max_dem_failcount

    set dem_passcount 0
    set dem_failcount 0

    print_addr_of "foo::operator&&(foo &)"
    print_addr_of "foo::operator&=(foo &)"
    print_addr_of "foo::operator&(foo &)"
    print_addr_of "foo::operator/=(foo &)"
    print_addr_of "foo::operator^=(foo &)"
    print_addr_of "foo::operator<<=(foo &)"
    print_addr_of "foo::operator%=(foo &)"
    print_addr_of "foo::operator-=(foo &)"
    print_addr_of "foo::operator*=(foo &)"
    print_addr_of "foo::operator|=(foo &)"
    print_addr_of "foo::operator+=(foo &)"
    print_addr_of "foo::operator>>=(foo &)"
    print_addr_of "foo::operator=(foo &)"
    print_addr_of "foo::operator()(foo &)"
    print_addr_of "foo::operator, (foo &)"
    print_addr_of "foo::operator~(void)"
    print_addr_of "foo::operator delete(void *)"
    print_addr_of "foo::operator/(foo &)"
    print_addr_of "foo::operator==(foo &)"

    if $dem_failcount>$max_dem_failcount then {
	fail "remaining tests suppressed after $dem_failcount failures..."
	return
    }

    print_addr_of "foo::operator^(foo &)"
    print_addr_of "foo::operator>=(foo &)"
    print_addr_of "foo::operator>(foo &)"
    print_addr_of "foo::operator<=(foo &)"
    print_addr_of "foo::operator<<(foo &)"
    print_addr_of "foo::operator<(foo &)"
    print_addr_of "foo::operator%(foo &)"
    print_addr_of "foo::operator-(foo &)"
    print_addr_of "foo::operator*(foo &)"
    print_addr_of "foo::operator--(int)"
    print_addr_of "foo::operator!=(foo &)"
    print_addr_of "foo::operator!(void)"
    print_addr_of "foo::operator new(int)"
    print_addr_of "foo::operator||(foo &)"
    print_addr_of "foo::operator char *(void)"
    print_addr_of "foo::operator int(void)"
    print_addr_of "foo::operator|(foo &)"
    print_addr_of "foo::operator+(foo &)"
    print_addr_of "foo::operator++(int)"
    print_addr_of "foo::operator->(void)"
    print_addr_of "foo::operator->*(foo &)"
    print_addr_of "foo::operator>>(foo &)"
    print_addr_of "foo::operator\[\](foo &)"

    if $dem_passcount then {
	pass "$dem_passcount correct fully qualified operator function lookups"
    }
}

#
# Test overloaded functions (1 arg).
#

proc test_paddr_overloaded_functions {} {
    global dem_passcount
    global dem_failcount
    global max_dem_failcount

    set dem_passcount 0
    set dem_failcount 0

    print_addr_of "overload1arg(signed char)"
    print_addr_of "overload1arg(unsigned char)"
    print_addr_of "overload1arg(unsigned int)"
    print_addr_of "overload1arg(unsigned long)"
    print_addr_of "overload1arg(unsigned short)"
    print_addr_of "overload1arg(char)"
    print_addr_of "overload1arg(double)"
    print_addr_of "overload1arg(float)"
    print_addr_of "overload1arg(int)"
    print_addr_of "overload1arg(long)"
    print_addr_of "overload1arg(short)"
    print_addr_of "overload1arg(void)"

    if $dem_failcount>$max_dem_failcount then {
	fail "remaining tests suppressed after $dem_failcount failures..."
	return
    }

    print_addr_of "overloadargs(int)"
    print_addr_of "overloadargs(int, int)"
    print_addr_of "overloadargs(int, int, int)"
    print_addr_of "overloadargs(int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int, int)"
    print_addr_of "overloadargs(int, int, int, int, int, int, int, int, int, int, int)"

    if $dem_passcount then {
	pass "$dem_passcount correct fully qualified overloaded function lookups"
    }
}

proc test_paddr_hairy_functions {} {
    global dem_passcount
    global dem_failcount
    global max_dem_failcount

    set dem_passcount 0
    set dem_failcount 0

    print_addr_of "hairyfunc1(int)"
    print_addr_of "hairyfunc2(int (*)(char *))"
    print_addr_of "hairyfunc3(int (*)(short (*)(long *)))"
    print_addr_of "hairyfunc4(int (*)(short (*)(char *)))"
    print_addr_of "hairyfunc5(int (*(*)(char *))(long))"
    print_addr_of "hairyfunc6(int (*(*)(int *))(long))"
    print_addr_of "hairyfunc7(int (*(*)(int (*)(char *)))(long))"

    if $dem_passcount then {
	pass "$dem_passcount correct fully qualified hairy function lookups"
    }
}

proc do_tests {} {
    global prms_id
    global bug_id
    global subdir
    global objdir
    global srcdir
    global binfile
    global prompt

    set prms_id 0
    set bug_id 0

    # Start with a fresh gdb.

    gdb_exit
    gdb_start
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_load $objdir/$subdir/$binfile

    send "set language c++\n"
    expect -re "$prompt $"
    send "set width 0\n"
    expect -re "$prompt $"

    test_paddr_overloaded_functions
    test_paddr_operator_functions
    test_paddr_hairy_functions
    test_lookup_operator_functions
}

# Check to see if we have an executable to test.  If not, then either we
# haven't tried to compile one, or the compilation failed for some reason.
# In either case, just notify the user and skip the tests in this file.

set binfile "gdbme"
set srcfile $binfile.cc

if ![file exists $objdir/$subdir/$binfile] then {
    if $all_flag then {
	warning "$binfile does not exist; tests suppressed."
    }
} else {
    do_tests
}
