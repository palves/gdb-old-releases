# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set binfile "gdbme"
set srcfile $binfile.c

if ![file exists $objdir/$subdir/$binfile] then {
    error "$objdir/$subdir/$binfile does not exist"
    continue
}

# The a29k can't call functions, so don't even bother with this test.
if [istarget "a29k-*-udi"] then {
    setup_xfail "a29k-*-udi" 2416
    fail "a29k-*-udi can not call functions"
    continue
}

# Set the current language to C.  This counts as a test.  If it
# fails, then we skip the other tests.

proc set_lang_c {} {
    global prompt

    send "set language c\n"
    expect {
	-re ".*$prompt $" {}
	timeout { fail "set language c (timeout)" ; return 0 }
    }

    send "show language\n"
    expect {
	-re ".* source language is \"c\".*$prompt $" {
	    pass "set language to \"c\""
	    return 1
	}
	-re ".*$prompt $" {
	    fail "setting language to \"c\""
	    return 0
	}
	timeout {
	    fail "can't show language (timeout)"
	    return 0
	}
    }
}

# FIXME:  Before calling this proc, we should probably verify that
# we can call inferior functions and get a valid integral value
# returned.
# Note that it is OK to check for 0 or 1 as the returned values, because C
# specifies that the numeric value of a relational or logical expression
# (computed in the inferior) is 1 for true and 0 for false.

proc do_function_calls {} {
    global timeout

    set otimeout $timeout
    set timeout 120

    gdb_test "p t_char_values(0,0)" " = 0"
    gdb_test "p t_char_values('a','b')" " = 1"
    gdb_test "p t_char_values(char_val1,char_val2)" " = 1"
    gdb_test "p t_char_values('a',char_val2)" " = 1"
    gdb_test "p t_char_values(char_val1,'b')" " = 1"

    gdb_test "p t_short_values(0,0)" " = 0"
    gdb_test "p t_short_values(10,-23)" " = 1"
    gdb_test "p t_short_values(short_val1,short_val2)" " = 1"
    gdb_test "p t_short_values(10,short_val2)" " = 1"
    gdb_test "p t_short_values(short_val1,-23)" " = 1"

    gdb_test "p t_int_values(0,0)" " = 0"
    gdb_test "p t_int_values(87,-26)" " = 1"
    gdb_test "p t_int_values(int_val1,int_val2)" " = 1"
    gdb_test "p t_int_values(87,int_val2)" " = 1"
    gdb_test "p t_int_values(int_val1,-26)" " = 1"

    gdb_test "p t_long_values(0,0)" " = 0"
    gdb_test "p t_long_values(789,-321)" " = 1"
    gdb_test "p t_long_values(long_val1,long_val2)" " = 1"
    gdb_test "p t_long_values(789,long_val2)" " = 1"
    gdb_test "p t_long_values(long_val1,-321)" " = 1"

    gdb_test "p t_float_values(0.0,0.0)" " = 0"
    gdb_test "p t_float_values(3.14159,-2.3765)" " = 1"
    gdb_test "p t_float_values(float_val1,float_val2)" " = 1"
    gdb_test "p t_float_values(3.14159,float_val2)" " = 1"
    gdb_test "p t_float_values(float_val1,-2.3765)" " = 1"

    gdb_test "p t_double_values(0.0,0.0)" " = 0"
    gdb_test "p t_double_values(45.654,-67.66)" " = 1"
    gdb_test "p t_double_values(double_val1,double_val2)" " = 1"
    gdb_test "p t_double_values(45.654,double_val2)" " = 1"
    gdb_test "p t_double_values(double_val1,-67.66)" " = 1"

    gdb_test "p t_string_values(string_val2,string_val1)" " = 0"
    gdb_test "p t_string_values(string_val1,string_val2)" " = 1"
    gdb_test "p t_string_values(\\\"string 1\\\",\\\"string 2\\\")" " = 1"
    gdb_test "p t_string_values(\\\"string 1\\\",string_val2)" " = 1"
    gdb_test "p t_string_values(string_val1,\\\"string 2\\\")" " = 1"

    gdb_test "p t_char_array_values(char_array_val2,char_array_val1)" " = 0"
    gdb_test "p t_char_array_values(char_array_val1,char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(\\\"carray 1\\\",\\\"carray 2\\\")" " = 1"
    gdb_test "p t_char_array_values(\\\"carray 1\\\",char_array_val2)" " = 1"
    gdb_test "p t_char_array_values(char_array_val1,\\\"carray 2\\\")" " = 1"

    gdb_test "p doubleit(4)" " = 8"
    gdb_test "p add(4,5)" " = 9"
    gdb_test "p t_func_values(func_val2,func_val1)" " = 0"
    gdb_test "p t_func_values(func_val1,func_val2)" " = 1"
    gdb_test "p t_func_values(add,func_val2)" " = 1"
    gdb_test "p t_func_values(func_val1,doubleit)" " = 1"
    gdb_test "p t_call_add(func_val1,3,4)" " = 7"
    gdb_test "p t_call_add(add,3,4)" " = 7"

    gdb_test "p t_enum_value1(enumval1)" " = 1"
    gdb_test "p t_enum_value1(enum_val1)" " = 1"
    gdb_test "p t_enum_value1(enum_val2)" " = 0"

    gdb_test "p t_enum_value2(enumval2)" " = 1"
    gdb_test "p t_enum_value2(enum_val2)" " = 1"
    gdb_test "p t_enum_value2(enum_val1)" " = 0"

    gdb_test "p sum_args(1,{2})" " = 2"
    gdb_test "p sum_args(2,{2,3})" " = 5"
    gdb_test "p sum_args(3,{2,3,4})" " = 9"
    gdb_test "p sum_args(4,{2,3,4,5})" " = 14"
    gdb_test "p sum10 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)" " = 55"

    set timeout $otimeout
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $objdir/$subdir/$binfile

send "set print sevenbit-strings\n" ; expect -re "$prompt $"
send "set print address off\n" ; expect -re "$prompt $"
send "set width 0\n" ; expect -re "$prompt $"

if [set_lang_c] then {
    if [runto main] then {
	do_function_calls
    } else {
	fail "C function calling tests suppressed"
    }
} else {
    fail "C function calling tests suppressed"
}
return 0
