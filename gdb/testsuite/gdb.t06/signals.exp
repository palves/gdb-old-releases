if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

gdb_reinitialize_dir $srcdir/$subdir
set binfile $objdir/$subdir/signals

proc signal_tests_1 {} {
    global prompt
    if [runto main] then {
	gdb_test "next" "signal \[(\]+SIGUSR1" \
		"next over signal \[(\]SIGALRM, handler\[)\]+"
	gdb_test "next" "alarm \[(\]" \
		"next over signal \[(\]+SIGUSR1, handler\[)\]+"
	gdb_test "next" "\[+\]+count" \
		"next over alarm (1)"
	# An alarm has been signaled, give the signal time to get delivered.
	exec sleep 2

	send "next\n"
	expect {
	    -re "alarm .*$prompt $" { pass "next to 2nd alarm (1)" }
	    -re "Program exited with code.*$prompt $" {

		# This is apparently a bug in the UnixWare kernel (but
		# has not been investigated beyond the
		# resume/target_wait level, and has not been reported
		# to Univel).  If it steps when a signal is pending,
		# it does a continue instead.  I don't know whether
		# there is a workaround.

		# Perhaps this problem exists on other SVR4 systems;
		# but (a) we have no reason to think so, and (b) if we
		# put a wrong xfail here, we never get an XPASS to let
		# us know that it was incorrect (and then if such a
		# configuration regresses we have no way of knowing).
		# Solaris is not a relevant data point either way
		# because it lacks single stepping.

		setup_xfail "i*86-univel-sysv4*"
		fail "'next' behaved as 'continue'"
		return 0
	    }
	    timeout { fail "next to 2nd alarm (1); (timeout)" }
	    eof { fail "next to 2nd alarm (1); (eof)" }
	}

	gdb_test "break handler" "Breakpoint \[0-9\]* at"
	gdb_test "next" "\[+\]+count" "next to 2nd ++count"
	# An alarm has been signaled, give the signal time to get delivered.
	exec sleep 2

	send "next\n"
	expect {
	    -re "Breakpoint.*handler.*$prompt $" { pass "next" }
	    -re "Program received signal SIGEMT.*$prompt $" {
		# Don't know why it gets this signal, or whether GDB
		# could do anything about it.
		setup_xfail "m68*-*-sunos*"
		fail "next"
		gdb_test "signal 0" "Breakpoint.*handler"
	    }
	    timeout { fail "(timeout)" }
	    eof { fail "(eof)" }
	}

	# This doesn't test that main is frame #2, just that main is frame
	# #2, #3, or higher.  At some point this should be fixed (but
	# it quite possibly would introduce new FAILs on some systems).
	gdb_test "backtrace" "#0.*handler.*#1.*#2.*main"

	gdb_test "break func1" "Breakpoint \[0-9\]* at"
	gdb_test "break func2" "Breakpoint \[0-9\]* at"
	gdb_test "continue" "Breakpoint.*func1"
	gdb_test "signal SIGUSR1" "Breakpoint.*handler"

	# Will tend to wrongly require an extra continue.

	# The problem here is that the breakpoint at func1 will be
	# inserted, and when the system finishes with the signal
	# handler it will try to execute there.  For GDB to try to
	# remember that it was going to step over a breakpoint when a
	# signal happened, distinguish this case from the case where
	# func1 is called from the signal handler, etc., seems
	# exceedingly difficult.  So don't expect this to get fixed
	# anytime soon.

	setup_xfail "*-*-*"
	gdb_test "continue" "Breakpoint.*func2"

	# FIXME: This "continue" should be sent only if the above was
	# indeed a FAIL
	gdb_test "continue" "Breakpoint.*func2"

	exec sleep 2

        # GDB yanks out the breakpoints to step over the breakpoint it
        # stopped at, which means the breakpoint at handler is yanked.
	# But if NO_SINGLE_STEP, we won't get another chance to reinsert
	# them (at least not with procfs, where we tell the kernel not
	# to tell gdb about `pass' signals).  So the fix would appear to
	# be to just yank that one breakpoint when we step over it.

	setup_xfail "sparc-*-*"
	setup_xfail "rs6000-*-*"

	# If you step the inferior with a signal, most kernels will step
	# into sigtramp.  But apparently the sun3 kernel (4.1.1) does not
	# do so.  The fix would be the same as for the NO_SINGLE_STEP case.
	setup_xfail "m68*-*-sunos4*"

	gdb_test "continue" "Breakpoint.*handler"

	# If the NO_SINGLE_STEP failure happened, we have already exited.
	# If we succeeded a continue will return from the handler to func2.
	# GDB now has `forgotten' that it intended to step over the
	# breakpoint at func2 and will stop at func2.
	setup_xfail "*-*-*"
	# The sun3 will also be `forgetful' but it already got the spurious
	# stop at func2 and this continue will work.
	clear_xfail "m68*-*-sunos4*"
	gdb_test "continue" "Program exited with code 010"
    }
}

# On a few losing systems, ptrace (PT_CONTINUE) or ptrace (PT_STEP)
# causes pending signals to be cleared, which causes these tests to
# get nowhere fast.  This is totally losing behavior (perhaps there
# are cases in which is it useful but the user needs more control,
# which they mostly have in GDB), but some people apparently think it
# is a feature.  It is documented in the ptrace manpage on Motorola
# Delta Series sysV68 R3V7.1 and on HPUX 9.0.  Even the non-HPUX PA
# OSes (BSD and OSF/1) seem to have figured they had to copy this
# braindamage.

if {[ istarget "m68*-motorola-*" ] || [ istarget "hppa*-*-bsd*" ] ||
    [ istarget "*-*-hpux*" ] || [ istarget "hppa*-*-osf*" ]} then {
  setup_xfail "*-*-*"
  fail "ptrace loses on signals on this target"
  return 0
}

if ![file exists $binfile] then {
    warning "$binfile does not exist; tests suppressed"
} else {
    gdb_load $binfile
    signal_tests_1

    # Force a resync, so we're looking at the right prompt.  On SCO we
    # were getting out of sync (I don't understand why).
    send "p 1+1\n"
    expect {
	-re "= 2.*$prompt $" {}
	default { perror "sync trouble in signals.exp" }
    }

    if [runto main] then {
	gdb_test "break handler if 0" "Breakpoint \[0-9\]* at"
	gdb_test "set \\\$handler_breakpoint_number = \\\$bpnum" ""

	# Get to the point where a signal is waiting to be delivered
	gdb_test "next" "signal \[(\]+SIGUSR1"
	gdb_test "next" "alarm \[(\]+"
	gdb_test "next" "\[+\]+count"
	# Give the signal time to get delivered
	exec sleep 2

	# Now call a function.  When GDB tries to run the stack dummy,
	# it will hit the breakpoint at handler.  Provided it doesn't
	# lose its cool, this is not a problem, it just has to note
	# that the breakpoint condition is false and keep going.

	gdb_test "p func1 ()" "^p func1 \[)(\]+\r\n.\[0-9\]* = void"

	# Make sure the count got incremented.

	# Haven't investigated this xfail
	setup_xfail "rs6000-*-*"
	gdb_test "p count" "= 2"
	if [istarget "rs6000-*-*"] { return 0 }

	gdb_test "condition \\\$handler_breakpoint_number" "now unconditional"
	gdb_test "next" "alarm \[(\]+"
	gdb_test "next" "\[+\]+count"
	exec sleep 2

	# This time we stop when GDB tries to run the stack dummy.
	# So it is OK that we do not print the return value from the function.
	gdb_test "p func1 ()" \
"Breakpoint \[0-9\]*, handler.*
The program being debugged stopped while in a function called from GDB"
	# But we should be able to backtrace...
	gdb_test "bt" "#0.*handler.*#1.*#2.*main"
	# ...and continue...
	gdb_test "continue" "Continuing"
	# ...and then count should have been incremented
	gdb_test "p count" "= 5"
    }
}
return 0
