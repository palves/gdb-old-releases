# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

# Generic gdb subroutines that should work for any target.  If these
# need to be modified for any target, it can be done with a variable
# or by passing arguments.

global GDB
if ![info exists GDB] then {
    set GDB [transform gdb]
}

global GDBFLAGS
if ![info exists GDBFLAGS] then {
    set GDBFLAGS ""
}

#
# gdb_version -- extract and print the version number of gcc
#
proc default_gdb_version {} {
    global GDB
    global GDBFLAGS
    if {[which $GDB] != 0} then {
	set tmp [exec echo "q" | $GDB]
	regexp " \[0-9\.\]+" $tmp version
	clone_output "[which $GDB] version$version $GDBFLAGS\n"
    } else {
	warning "$GDB does not exist"
    }
}

#
# gdb_unload -- unload a file if one is loaded
#

proc gdb_unload {} {
    global verbose
    global GDB
    global prompt
    send "file\n"
    expect {
	-re "No exec file now.*\r" { exp_continue }
	-re "No symbol file now.*\r" { exp_continue }
	-re "A program is being debugged already..*Kill it.*y or n. $"\
	    { send "y\n"
		verbose "\t\tKilling previous program being debugged"
	    exp_continue
	}
	-re "Discard symbol table from .*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "$prompt $" {}
	timeout {
	    perror "couldn't unload file in $GDB (timed out)."
	    return -1
	}
    }
}

# Many of the tests depend on setting breakpoints at various places and
# running until that breakpoint is reached.  At times, we want to start
# with a clean-slate with respect to breakpoints, so this utility proc 
# lets us do this without duplicating this code everywhere.
#

proc delete_breakpoints {} {
    global prompt

    send "delete breakpoints\n"
    expect {
	-re "Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "y\r\n$prompt $" {}
	-re ".*$prompt $" { perror "Delete all breakpoints" ; return }
	timeout { error "Delete all breakpoints (timeout)" ; return }
    }
    send "info breakpoints\n"
    expect {
	-re "No breakpoints or watchpoints..*$prompt $" {}
	-re ".*$prompt $" { perror "breakpoints not deleted" ; return }
	timeout { error "info breakpoints (timeout)" ; return }
    }
}


#
# Set breakpoint at function and run gdb until it breaks there.
# Since this is the only breakpoint that will be set, if it stops
# at a breakpoint, we will assume it is the one we want.  We can't
# just compare to "function" because it might be a fully qualified,
# single quoted C++ function specifier.
#

proc runto { function } {
    global prompt
    global decimal

    send "delete\n"
    expect {
	-re "delete.*Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    expect {
		-re "$prompt $" {}
		timeout { fail "deleting breakpoints (timeout)" ; return 0 }
	    }
	}
	-re ".*$prompt $" {}
	timeout { fail "deleting breakpoints (timeout)" ; return 0 }
    }

    send "break $function\n"
    # The first regexp is what we get with -g, the second without -g.
    expect {
	-re "Break.* at .*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $function" ; return 0 }
	timeout { fail "setting breakpoint at $function (timeout)" ; return 0 }
    }

    send "run\n"
    # the "at foo.c:36" output we get with -g.
    # the "in func" output we get without -g.
    expect {
	-re "The program .* has been started already.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "Starting.*Break.* at .*:$decimal.*$prompt $" { return 1 }
	-re "Breakpoint \[0-9\]*, \[0-9xa-f\]* in $function.*$prompt $" { 
	    return 1
	}
	-re "$prompt $" { fail "running to $function" ; return 0 }
	timeout { fail "running to $function (timeout)" ; return 0 }
    }
}

#
# gdb_test -- send a command to gdb and test the result.
#             Takes three parameters.
#             Parameters:
#                First one is the command to execute,
#                Second one is the pattern to match for a PASS,
#                Third one is an optional message to be printed. If this
#                  a null string "", then the pass/fail messages are not printed.
#             Returns:
#                1 if the test failed,
#                0 if the test passes,
#               -1 if there was an internal error.
#
proc gdb_test { args } {
    global verbose
    global prompt
    global GDB
    global spawn_id

    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set command [lindex $args 0]
    set pattern [lindex $args 1]

    if $verbose>2 then {
	send_user "Sending \"$command\" to gdb\n"
	send_user "Looking to match \"$pattern\"\n"
	send_user "Message is \"$message\"\n"
    }

    set result -1
    set errmess ""
    # trap the send so any problems don't crash things
    catch "send \"$command\n\"" errmess
    if [string match "write.spawn_id=\[0-9\]+.:" $errmess] then {
	perror "sent \"$command\" got expect error \"$errmess\""
	catch "close"
	gdb_start
	return -1
    }

    expect {
	-re ".*Ending remote debugging.*$prompt$" {
	    if ![isnative] then {
		warning "Can`t communicate to remote target."
	    }
	    gdb_exit
	    gdb_start
	    set result -1
	}
	-re "$pattern.*$prompt $" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
	-re "Undefined command:.*$prompt" {
	    perror "Undefined command \"$command\"."
	    set result 1
	}
	-re "Ambiguous command.*$prompt $" {
	    perror "\"$command\" is not a unique command name."
	    set result 1
	}
	-re ".*$prompt $" {
	    if ![string match "" $message] then {
		fail "$message"
	    }
	    set result 1
	}
	"<return>" {
	    send "\n"
	    perror "Window too small."
	}
	-re "\[(\]+y or n\[)\]+ " {
	    send "n\n"
	    perror "Got interactive prompt."
	}
	eof {
	    perror "Process no longer exists"
	    return -1
	}
	buffer_full {
	    perror "internal buffer is full."
	}
	timeout	{
	    fail "(timeout) $message"
	    set result 1
	}
    }
    return $result
}

proc gdb_reinitialize_dir { subdir } {
    global prompt

   send "dir\n"
    expect {
	-re "Reinitialize source path to empty.*" {
	    send "y\n"
	    expect {
		-re "Source directories searched.*$prompt $" {
		    send "dir $subdir\n"
		    expect {
			-re "Source directories searched.*$prompt $" {
			    verbose "Dir set to $subdir"
			}
			-re ".*$prompt $" {
			    perror "Dir \"$subdir\" failed."
			}
		    }
		}
		-re ".*$prompt $" {
		    perror "Dir \"$subdir\" failed."
		}
	    }
	}
	-re ".*$prompt $" {
	    perror "Dir \"$subdir\" failed."
	}
    }
}

#
# gdb_exit -- exit the GDB, killing the target program if necessary
#
proc default_gdb_exit {} {
    global GDB
    global GDBFLAGS
    global verbose

    verbose "Quitting $GDB $GDBFLAGS"

    # This used to be 1 for unix-gdb.exp
    set timeout 5

    catch "send \"quit\n\"" result
    # If the process has gone away (e.g. gdb dumped core), deal with it.
    if [string match "write\[(\]+spawn_id=\[0-9)\]+:" $result] then {
	catch "close"
	# FIXME:  Shouldn't we call "wait" too?
	return -1
    }
    # FIXME: What is this catch statement doing here?  Won't it prevent us
    # from getting errors that we'd rather see?
	expect {
	    eof { 
		verbose "Got EOF from $GDB" 2
	    }
	    timeout { 
		verbose "Got TIMEOUT from $GDB" 2
	    }
	    -re "The program is running.  Quit anyway.*y or n. $" {
		send "y\n"
		verbose "Killing program being debugged" 2
	    }
    }

    # Before this was here sometimes "uit" would get sent to the next GDB
    # (assuming this is immediately followed by gdb_start), which would
    # cause a loss of syncronization (i.e. all the stuff that swallows a
    # prompt would swallow the wrong one).
    wait
}

#
# gdb_load -- load a file into the debugger.
#             return a -1 if anything goes wrong.
#
proc gdb_file_cmd { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global prompt
    global spawn_id

    send "file $arg\n"
    expect {
        -re "Reading symbols from.*done.*$prompt $" {
            verbose "\t\tLoaded $arg into the $GDB"
            return 0
        }
        -re "has no symbol-table.*$prompt $" {
            perror "$arg wasn't compiled with \"-g\""
            return -1
        }
        -re "A program is being debugged already.*Kill it.*y or n. $" {
            send "y\n"
                verbose "\t\tKilling previous program being debugged"
            exp_continue
        }
        -re "Load new symbol table from \".*\".*y or n. $" {
            send "y\n"
            expect {
                -re "Reading symbols from.*done.*$prompt $" {
                    verbose "\t\tLoaded $arg with new symbol table into $GDB"
                    return 0
                }
                timeout {
                    perror "(timeout) Couldn't load $arg, other program already l
oaded."
                    return -1
                }
            }
	}
        -re ".*No such file or directory.*$prompt $" {
            perror "($arg) No such file or directory\n"
            return -1
        }
        -re "$prompt $" {
            perror "couldn't load $arg into $GDB."
            return -1
            }
        timeout {
            perror "couldn't load $arg into $GDB (timed out)."
            return -1
        }
        eof {
            # This is an attempt to detect a core dump, but seems not to
            # work.  Perhaps we need to match .* followed by eof, in which
            # expect does not seem to have a way to do that.
            error "couldn't load $arg into $GDB (end of file)."
            return -1
        }
    }
}

#
# FIXME: this is a copy of the new library procedure, but it's here too
# till the new dejagnu gets installed everywhere. I'd hate to break the
# gdb tests suite.
#
global argv0
if ![info exists argv0] then {
    proc exp_continue { } {
	continue -expect
    }
}


