dnl	This file is an input file used by the GNU "autoconf" program to
dnl	generate the file "configure", which is run during Tcl installation
dnl	to configure the system for the local environment.
AC_INIT(tcl.h)

AC_PROG_INSTALL
AC_PROG_RANLIB
AC_PREFIX(tclsh)
CC=${CC-cc}
AC_SUBST(CC)
AC_C_CROSS

#--------------------------------------------------------------------
# CYGNUS LOCAL:
# This is for LynxOS, which needs a flag to force true POSIX when
# building. It's weirder than that, cause the flag varies depending
# how old the compiler is. So...
# -X is for the old "cc" and "gcc" (based on 1.42)
# -mposix is for the new gcc (at least 2.5.8)
# This modifies the value of $CC to have the POSIX flag added
# so everything will configure correctly.
#--------------------------------------------------------------------
CY_TCL_LYNX_POSIX

#--------------------------------------------------------------------
#	Supply substitutes for missing POSIX library procedures, or
#	set flags so Tcl uses alternate procedures.
#--------------------------------------------------------------------

AC_REPLACE_FUNCS(getcwd strncasecmp)
AC_REPLACE_FUNCS(strtol tmpnam waitpid)
AC_FUNC_CHECK(gettimeofday, , AC_DEFINE(NO_GETTOD))
AC_FUNC_CHECK(getwd, , AC_DEFINE(NO_GETWD))
AC_FUNC_CHECK(wait3, , AC_DEFINE(NO_WAIT3))

#--------------------------------------------------------------------
#	On a few very rare systems, all of the libm.a stuff is
#	already in libc.a.  Set compiler flags accordingly.
#	Also, Linux requires the "ieee" library for math to work
#	right.
#--------------------------------------------------------------------

AC_FUNC_CHECK(sin, MATH_LIBS="", MATH_LIBS="-lm")
AC_SUBST(MATH_LIBS)
AC_CHECK_LIB(ieee, main, [MATH_LIBS="$MATH_LIBS -lieee"])

#--------------------------------------------------------------------
#	Supply substitutes for missing POSIX header files.  Special
#	notes:
#	    - Sprite's dirent.h exists but is bogus.
#	    - stdlib.h doesn't define strtol, strtoul, or
#	      strtod insome versions of SunOS
#	    - some versions of string.h don't declare procedures such
#	      as strstr
#--------------------------------------------------------------------
AC_HAVE_HEADERS(unistd.h)
AC_CACHE_VAL(ac_cv_header_dirent_h,[
AC_TRY_COMPILE([
#include <sys/types.h>
#include <dirent.h>],[
#ifndef _POSIX_SOURCE
#   ifdef __Lynx__
	/*
	 * Generate compilation error to make the test fail:  Lynx headers
	 * are only valid if really in the POSIX environment.
	 */

	missing_procedure();
#   endif
#endif
DIR *d;
struct dirent *entryPtr;
char *p;
d = opendir("foobar");
entryPtr = readdir(d);
p = entryPtr->d_name;
closedir(d);
], ac_cv_header_dirent_h=yes, ac_cv_header_dirent_h=no)
AC_HEADER_EGREP([Sprite version.* NOT POSIX], ac_cv_header_dirent_h=no)])
if test x"$ac_cv_header_dirent_h" = x"no" ; then
    AC_DEFINE(NO_DIRENT_H)
fi

dnl this could be replaced by AC_HEADER_STDC, but it doesn't look
dnl for errno.h and limits.h
AC_CHECK_HEADER(errno.h,  , AC_DEFINE(NO_ERRNO_H))
AC_CHECK_HEADER(float.h,  , AC_DEFINE(NO_FLOAT_H))
AC_CHECK_HEADER(limits.h, , AC_DEFINE(NO_LIMITS_H))

dnl ac_cv_header_stdlib_h is the default name for the cache variable
dnl set from AC_CHECK_HEADER for this test
AC_CACHE_VAL(ac_cv_header_stdlib_h,[
AC_CHECK_HEADER(stdlib.h)
if test x"$ac_cv_header_stdlib_h" = x"yes" ; then
  AC_EGREP_HEADER(strtol,  stdlib.h, , ac_cv_header_stdlib_h=no)
  AC_EGREP_HEADER(strtoul, stdlib.h, , ac_cv_header_stdlib_h=no)
  AC_EGREP_HEADER(strtod,  stdlib.h, , ac_cv_header_stdlib_h=no)
fi])
if test x"$ac_cv_header_stdlib_h" = x"no"; then
  AC_DEFINE(NO_STDLIB_H)
fi

dnl ac_cv_header_string_h is the default name for the cache variable
dnl set from AC_CHECK_HEADER for this test
AC_CACHE_VAL(ac_cv_header_string_h,[
AC_CHECK_HEADER(string.h, ac_cv_header_string_h=yes, ac_cv_header_string_h=no)
if test x"$ac_cv_header_string_h" = x"yes" ; then
  AC_EGREP_HEADER(strstr,   string.h, , ac_cv_header_string_h=no)
  AC_EGREP_HEADER(strerror, string.h, , ac_cv_header_string_h=no)
fi])
if test x"$ac_cv_c_string_h" = x"no" ; then
    AC_DEFINE(NO_STRING_H)
fi
AC_CHECK_HEADER(sys/time.h, , AC_DEFINE(NO_SYS_TIME_H))
AC_CHECK_HEADER(sys/wait.h, , AC_DEFINE(NO_SYS_WAIT_H))

#--------------------------------------------------------------------
#	On some systems strstr is broken: it returns a pointer even
#	even if the original string is empty.
#--------------------------------------------------------------------
dnl ac_cv_func_strstr is default name for the cache variable
dnl AC_CHECK_FUNC(strstr), which we don't use. If this doesn't
dnl compile, we know we don't have it, so why check twice.
AC_MSG_CHECKING([for a working strstr])
AC_CACHE_VAL(ac_cv_func_strstr,[
AC_TRY_RUN([
extern int strstr();
int main()
{
  exit(strstr("\0test", "test") ? 1 : 0);
}], ac_cv_func_strstr=yes , ac_cv_func_strstr=no,
AC_WARN([No support for cross configuring]))])
if test x"$ac_cv_func_strstr" = x"no" ; then
  LIBOBJS="$LIBOBJS strstr.o"
  AC_MSG_RESULT(no)
else
  AC_MSG_RESULT(yes)
fi

#--------------------------------------------------------------------
#	Check for strtoul function.  This is tricky because under some
#	versions of AIX strtoul returns an incorrect terminator
#	pointer for the string "0".
#--------------------------------------------------------------------

dnl ac_cv_func_strtoul is default name for the cache variable
dnl AC_CHECK_FUNC(strtoul), which we don't use. If this doesn't
dnl compile, we know we don't have it, so why check twice.
AC_MSG_CHECKING([for a working strtoul])
AC_CACHE_VAL(ac_cv_func_strtoul,[
AC_TRY_RUN([
extern int strtoul();
int main()
{
    char *string = "0";
    char *term;
    int value;
    value = strtoul(string, &term, 0);
    if ((value != 0) || (term != (string+1))) {
        exit(1);
    }
    exit(0);
}], ac_cv_func_strtoul=yes, ac_cv_func_strtoul=no,
AC_WARN([No support for cross configuring]))])
if test x"$ac_cv_func_strtoul" = x"no" ; then
  LIBOBJS="$LIBOBJS strtoul.o"
  AC_MSG_RESULT(no)
else
  AC_MSG_RESULT(yes)
fi

#--------------------------------------------------------------------
#	Check for the strtod function.  This is tricky because in some
#	versions of Linux strtod mis-parses strings starting with "+".
#--------------------------------------------------------------------

dnl ac_cv_func_strtoul is default name for the cache variable
dnl AC_CHECK_FUNC(strtod), which we don't use. If this doesn't
dnl compile, we know we don't have it, so why check twice.
AC_MSG_CHECKING([for a working strtod])
AC_CACHE_VAL(ac_cv_func_strtod,[
AC_TRY_RUN([
extern double strtod();
int main()
{
    char *string = " +69";
    char *term;
    double value;
    value = strtod(string, &term);
    if ((value != 69) || (term != (string+4))) {
	exit(1);
    }
    exit(0);
}], ac_cv_func_strtod=yes, ac_cv_func_strtod=no,
AC_WARN([No support for cross configuring]))])
if test x"$ac_cv_func_strtod" = x"no" ; then
  LIBOBJS="$LIBOBJS strtod.o"
  AC_MSG_RESULT(no)
else
  AC_MSG_RESULT(yes)
fi

#--------------------------------------------------------------------
#	Check for various typedefs and provide substitutes if
#	they don't exist.
#--------------------------------------------------------------------

AC_MODE_T
AC_PID_T
AC_SIZE_T
AC_UID_T

#--------------------------------------------------------------------
#	If a system doesn't have an opendir function (man, that's old!)
#	then we have to supply a different version of dirent.h which
#	is compatible with the substitute version of opendir that's
#	provided.  This version only works with V7-style directories.
#--------------------------------------------------------------------

AC_REPLACE_FUNCS(opendir)
AC_CHECK_FUNCS(opendir, , AC_DEFINE(USE_DIRENT2_H))

#--------------------------------------------------------------------
#	Check for the existence of sys_errlist (this is only needed if
#	there's no strerror, but I don't know how to conditionalize the
#	check).
#--------------------------------------------------------------------

dnl ac_cv_func_strerror is default name for the cache variable from
dnl AC_REPLACE_FUNCS(strerror)
AC_REPLACE_FUNCS(strerror)
if test x"$ac_cv_func_strerror" = x"no" ; then
  AC_MSG_CHECKING([for sys_errlist])
  AC_TRY_COMPILE(,[
  extern char *sys_errlist[];
  extern int sys_nerr;
  sys_errlist[sys_nerr-1][0] = 0;
  ], AC_MSG_RESULT(yes), [AC_MSG_RESULT(no) AC_DEFINE(NO_SYS_ERRLIST)])
fi

#--------------------------------------------------------------------
#	The check below checks whether <sys/wait.h> defines the type
#	"union wait" correctly.  It's needed because of weirdness in
#	HP-UX where "union wait" is defined in both the BSD and SYS-V
#	environments.  Checking the usability of WIFEXITED seems to do
#	the trick.
#--------------------------------------------------------------------

AC_MSG_CHECKING([for a working union wait])
AC_CACHE_VAL(ac_cv_c_union_wait,[
AC_TRY_COMPILE([
#include <sys/types.h> 
#include <sys/wait.h>], [
union wait x;
WIFEXITED(x);		/* Generates compiler error if WIFEXITED
			 * uses an int. */
], ac_cv_c_union_wait=yes, ac_cv_c_union_wait=no)])
if test x"$ac_cv_c_union_wait" = x"no" ; then
  AC_MSG_RESULT(no)
  AC_DEFINE(NO_UNION_WAIT)
else
  AC_MSG_RESULT(yes)
fi

#--------------------------------------------------------------------
#	Check to see whether the system supports the matherr function
#	and its associated type "struct exception".
#--------------------------------------------------------------------

AC_MSG_CHECKING([for matherr and it's struct exception])
AC_CACHE_VAL(ac_cv_c_matherr,[
AC_TRY_COMPILE([
#include <math.h>],[
struct exception x;
x.type = DOMAIN;
x.type = SING;
], ac_cv_c_matherr=yes, ac_cv_c_matherr=no)])
if test x"$ac_cv_c_matherr" = x"yes" ; then
  AC_DEFINE(NEED_MATHERR)
  AC_MSG_RESULT(no)
else
  AC_MSG_RESULT(yes)
fi
#--------------------------------------------------------------------
#	Check to see whether the system provides a vfork kernel call.
#	If not, then use fork instead.
#--------------------------------------------------------------------

AC_CHECK_FUNCS(vfork, , AC_DEFINE(vfork, fork))

AC_OUTPUT(Makefile)

